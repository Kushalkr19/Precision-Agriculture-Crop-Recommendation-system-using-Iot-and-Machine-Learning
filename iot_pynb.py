# -*- coding: utf-8 -*-
"""IOT .pynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qF_IiYRzfS5sZrTZ7jBJzg8yAB3ZUuc-
"""

import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt 
import seaborn as sns
from ipywidgets import interact
import os

import pickle
from flask import Flask,request,app,jsonify,url_for,render_template


df = pd.read_csv("Crop_recommendation.csv")

df.head()

df.describe()

print("Shape of the dfset:", df.shape)

df.isnull().sum()

df['label'].value_counts()

print("Average Ratio of Nitrogen in the Soil: {0:.2f}".format(df['N'].mean()))
print("Average Ratio of Phosphorous in the Soil: {0:.2f}".format(df['P'].mean()))
print("Average Ratio of Potassium in the Soil: {0:.2f}".format(df['K'].mean()))
print("Average Temperature in Celcius: {0:.2f}".format(df['temperature'].mean()))
print("Average Relative Humidity in %: {0:.2f}".format(df['humidity'].mean()))
print("Average PH Value of the Soil: {0:.2f}".format(df['ph'].mean()))
print("Average Rainfall in mm: {0:.2f}".format(df['rainfall'].mean()))

print("Some Interesting Patterns")
print("------------------------------------------------------------------------------")
print("Crops which requires very high ratio of Nitrogen in soil:", df[df['N'] > 120]['label'].unique())
print("Crops which requires very high ratio of Phosphorous in soil:", df[df['P'] > 100]['label'].unique())
print("Crops which requires very high ratio of Potassium in soil:", df[df['K'] > 200]['label'].unique())
print("Crops which requires very high Rainfall:", df[df['rainfall'] > 200]['label'].unique())
print("Crops which requires very low Temperature:", df[df['temperature'] < 10]['label'].unique())
print("Crops which requires very high Temperature:", df[df['temperature'] > 40]['label'].unique())
print("Crops which requires very low Humidity:", df[df['humidity'] < 20]['label'].unique())
print("Crops which requires very low pH:", df[df['ph'] < 4]['label'].unique())
print("Crops which requires very high pH:", df[df['ph'] > 9]['label'].unique())

from sklearn.cluster import KMeans

# removing the labels column

x = df.drop(['label'], axis = 1)

# selecting all the values of the df

x = x.values

# checking the shape

print(x.shape)

plt.rcParams['figure.figsize'] = (10, 4)

wcss = []
for i in range(1, 11):
    km = KMeans(n_clusters = i, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)
    km.fit(x)
    wcss.append(km.inertia_)

# lets plot the results

plt.plot(range(1, 11), wcss)
plt.title('The Elbow Method', fontsize = 20)
plt.xlabel('No of Clusters')
plt.ylabel('wcss')
plt.show()

km = KMeans(n_clusters = 4, init = 'k-means++', max_iter = 500, n_init = 10, random_state = 0)
y_means = km.fit_predict(x)

# lets find out the results

a = df['label']
y_means = pd.DataFrame(y_means) 
z = pd.concat([y_means, a], axis = 1)
z = z.rename(columns = {0: 'cluster'})

# lets check the clusters of each crops

print("Lets check the results after applying the KMeans clustering analysis \n")
print("Crops in First cluster:", z[z['cluster'] == 0]['label'].unique())
print("------------------------------------------------------------------------------")
print("Crops in Second cluster:", z[z['cluster'] == 1]['label'].unique())
print("------------------------------------------------------------------------------")
print("Crops in Third cluster:", z[z['cluster'] == 2]['label'].unique())
print("------------------------------------------------------------------------------")
print("Crops in Fourth cluster:", z[z['cluster'] == 3]['label'].unique())

y = df['label']
x = df.drop(['label'], axis = 1)

print("Shape of x:", x.shape)
print("Shape of y:", y.shape)

from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.3, random_state = 0)

print("The shape of x train:", x_train.shape)
print("The shape of x test:", x_test.shape)
print("The shape of y train:", y_train.shape)
print("The shape of y test:", y_test.shape)

"""# **LOGISTIC REGRESSION**"""

from sklearn.linear_model import LogisticRegression

model = LogisticRegression()
model.fit(x_train, y_train)
y_pred = model.predict(x_test)

"""## **RANDOM FOREST CLASIFIER**"""

from sklearn.ensemble import RandomForestClassifier
clf = RandomForestClassifier(n_estimators = 100)
clf.fit(x_train,y_train)
y_pred1 = clf.predict(x_test)

"""## **K-NEAREST NEIGHBORS**"""

from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(x_train,y_train)
y_pred2 = knn.predict(x_test)

from sklearn.metrics import confusion_matrix

# lets print the confusion matrix first

plt.rcParams['figure.figsize'] = (10, 10)
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot = True, cmap = 'binary')
plt.title("Confusion Matrix for Logistic Regression", fontsize = 15)
plt.show()

from sklearn.metrics import classification_report

cr = classification_report(y_test, y_pred)
print(cr)

"""## **LOGISTIC REGRESSION PREDICTION**"""

prediction = model.predict((np.array([[90,
                                     40,
                                     40,
                                     35,
                                     70,
                                     7,
                                     200]])))
print("The suggested crop for given climatic condition is:", prediction)

"""## **RANDOM FOREST PREDICTION**"""

prediction = clf.predict((np.array([[90,
                                     40,
                                     40,
                                     35,
                                     70,
                                     7,
                                     200]])))
print("The suggested crop for given climatic condition is:", prediction)

"""## **K-NEAREST NEIGHBORS PREDICTION**"""

prediction = knn.predict((np.array([[90,
                                     40,
                                     40,
                                     35,
                                     70,
                                     7,
                                     200]])))
print("The suggested crop for given climatic condition is:", prediction)

print("Accuracy of Logistic regression: ",model.score(x_test, y_test))

print("Accuracy of Random Forest Classifier : ",clf.score(x_test, y_test))

print("Accuracy of K-Nearest neighbors : ",knn.score(x_test,y_test))

"""# **LOGISTIC REGRESSION PICKLE FILE**"""

import pickle

with open('model_pickle','wb') as f:
  pickle.dump(model,f)

with open('model_pickle','rb') as f:
   lr = pickle.load(f)

lr.predict(np.array([[90,40,
                                     40,
                                     35,
                                     70,
                                     7,
                                     200]]))

"""# **Random forest pickle file**"""

with open('clf_pickle','wb') as f:
  pickle.dump(clf,f)

with open('clf_pickle','rb') as f:
   rf = pickle.load(f)

rf.predict(np.array([[90,40,
                                     40,
                                     35,
                                     70,
                                     7,
                                     200]]))

"""# **Streamlit dashboard creation**"""




import streamlit as st

st.write("""#Crop Recommendatation system
Predict the crop """)

from PIL import Image

image = Image.open('image.jpg')
st.image(image,caption='ML',use_column_width='True')

st.subheader('Data Information')

st.dataframe(df)

st.write(df.describe())

def get_user_input():
  N = st.sidebar.slider('Nitrogen',0,100)
  P = st.sidebar.slider('Phosporous',0,100)
  K = st.sidebar.slider('Potassium',0,100)
  temperature = st.sidebar.slider('Temperature',0,100)
  humidity = st.sidebar.slider('Humidity',0,100)
  rainfall = st.sidebar.slider('Rainfall',0,150)
  ph = st.sidebar.slider('ph',0,14)

  user_Data = {'N':N,
               'P':P,
               'K':K,
                'temperature':temperature,
               'rainfall':rainfall,
               'humidity':humidity,
               'ph':ph
               }
  features = pd.DataFrame(user_Data,index=[0])
  return features

user_input = get_user_input()
st.subheader('User Input:')
st.write(user_input)

st.subheader('Model Test Accuracy Score:')

st.write(str(clf.score(x_test, y_test)))

prediction1 = clf.predict(user_input)

st.subheader('Classification: ')
st.write(prediction1)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile IOT.pynb
# st.write("""#Crop Recommendatation system
# Predict the crop """)
